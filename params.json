{
  "name": "PageName",
  "tagline": "TagLine",
  "body": "##HM75手机安全卫士\r\n\r\n*start 2016/11/2 12:45:23* \r\n###day01\r\n- SVN仓库\r\n- 控件id命名规范\r\n- ep: tv_splash_versionname\r\n- StringWriter用法\r\n- Android中的json操作\r\n- Android连接网络不识别localhost\r\n- handler\r\n- SystemClock.sleep(2000) //睡眠两秒钟\r\n- xutils中的httputils的使用\r\n- 获取sd卡状态,Enviroment\r\n- 调用pakageInstaller安装应用,隐式意图\r\n- startActivityForResult\r\n- 异常处理,错误码,url连接设置conn.setConnectTimeout\r\n- 两种上下文的区别\r\n- 打包签名\r\n\r\n###day02\r\n- gridview用法\r\n- sharedPreferences\r\n\r\n###day03\r\n- 自定义属性,attrs.xml\r\n- 设置密码,md5\r\n- adb shell\r\n- 界面跳转\r\n- 手机防盗页面一\r\n- 状态选择器\r\n- 抽取样式\r\n- 监听手机物理按键点击事件\r\n\r\n###day04\r\n- 界面切换动画效果\r\n- 手势识别器\r\n- shape资源\r\n- 绑定sim卡,getSystemService，TelephoneyManager\r\n- 监听手机重启发送报警短信\r\n- 检测sim卡是否变化\r\n- 保存安全号码\r\n- 获取联系人\r\n- Android单元测试\r\n- 选择联系人,设置安全号码\r\n- 延时操作细节处理\r\n- FramLayout,写在下边的会出现在上面\r\n- 注解方式获取控件,xUtils---ViewUtils\r\n\r\n\r\n###day05\r\n- 异步加载框架\r\n- 修改进度条样式\r\n- 打开系统联系人界面选择联系人\r\n- 接受解析短信\r\n- 定位的三种方式\r\n\r\n###day06\r\n- 定位的具体代码\r\n- 创建服务进行定位操作\r\n- 超级管理员\r\n- 远程锁屏\r\n- 远程删除数据\r\n- 查询号码归属地之数据库优化\r\n- 拷贝数据库\r\n\r\n###day07\r\n- 监听文本变化\r\n- 抖动,震动的效果\r\n- 监听电话的状态\r\n- 自定义toast\r\n- 服务开启\r\n- 外拨电话显示归属地\r\n- 归属地风格\r\n- 随着手指移动\r\n\r\n###day08\r\n- 归属地位置回显\r\n- 防止空间移出屏幕\r\n- 多击事件\r\n- 通话界面设置归属地拖动更新位置\r\n- 小火箭\r\n- handler发送延迟消息\r\n- 黑名单数据库操作\r\n###day09\r\n- 查询全部数据\r\n- 通讯卫士界面展示\r\n- listview服用缓存\r\n- 黑名单删除,添加\r\n- 分批加载\r\n- listview滑动监听\r\n- 短信拦截\r\n- 电话拦截\r\n- 删除通话记录\r\n- 内容观察者,注册,注销\r\n- 获取系统应用程序信息\r\n###day10\r\n- 拆分系统程序和用户程序\r\n- 浮动显示程序个数\r\n- popuwinddow操作\r\n- popuwinddow动画\r\n- 控件点击事件\r\n- 卸载,启动,详情\r\n- 分享\r\n- 获取可用空间\r\n- 获取系统所有进程信息\r\n- 进程管理界面\r\n- checkboxBug解决\r\n- 全选和取消\r\n- 清理进程\r\n###day11\r\n- 运行进程个数及剩余总内存\r\n- 桌面小控件,生命周期\r\n- 一键清理\r\n- 锁屏解锁操作\r\n- 频幕适配\r\n- 快捷方式\r\n- 监听用户打开的应用程序\r\n##day12\r\n- 加锁解锁\r\n- 数据库优化\r\n- 获取短信\r\n- 备份短信\r\n- 短信备份进度条效果\r\n- 回调函数\r\n- 短信还原\r\n- 可扩展listview\r\n- 抽屉的效果\r\n\r\n###day13\r\n- 病毒简介\r\n- 手机杀毒界面,自定义进度条,layer-list\r\n- 进度条操作\r\n- 展示扫描软件的名称信息\r\n- 杀毒\r\n- fragment的使用\r\n- 获取缓存\r\n- 显示缓存应用\r\n- 清理缓存\r\n- 异常捕获\r\n- 代码混淆\r\n- 广告\r\n\r\n*end 2016/11/25 18:20:50* \r\n\r\n\r\n----------\r\n##自定义控件\r\n*start 2016/11/25 18:24:25* \r\n###day01\r\n- 系统控件\r\n- 优酷菜单\r\n- ViewPager\r\n- 下拉框\r\n- 单击滑动\r\n- 自定义属性\r\n\t- 测试\r\n\r\n```\r\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\r\nsuper.onActivityResult(requestCode, resultCode, data);\r\nif(requestCode == 10){\r\n    Toast.makeText(this, \"拍照成功\", 0).show();\r\n}\r\nelse if(requestCode == 20){\r\n    Toast.makeText(this, \"摄像成功\", 0).show();\r\n}\r\n}\r\n```\r\n\r\n- 测试文件\r\n##确定\r\n\r\n#服务两种启动方式\r\n* startService：服务被启动之后，跟启动它的组件没有一毛钱关系\r\n* bindService：跟启动它的组件同生共死\r\n* 绑定服务和解绑服务的生命周期方法：onCreate->onBind->onUnbind->onDestroy\r\n\r\n---\r\n#找领导办证\r\n* 把服务看成一个领导，服务中有一个banZheng方法，如何才能访问？\r\n* 绑定服务时，会触发服务的onBind方法，此方法会返回一个Ibinder的对象给MainActivity，通过这个对象访问服务中的方法\r\n* 绑定服务\r\n\r\n\t\tIntent intent = new Intent(this, BanZhengService.class);\r\n    \tbindService(intent, conn, BIND_AUTO_CREATE);\r\n* 绑定服务时要求传入一个ServiceConnection实现类的对象\r\n* 定义这个实现类\r\n\r\n\t\tclass MyServiceconn implements ServiceConnection{\r\n\t\t@Override\r\n\t\tpublic void onServiceConnected(ComponentName name, IBinder service) {\r\n\t\t\tzjr = (PublicBusiness) service;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic void onServiceDisconnected(ComponentName name) {\t\r\n\t\t}\r\n    \t\r\n    }\r\n* 创建实现类对象\r\n\r\n\t\t conn = new MyServiceconn();\r\n* 在服务中定义一个类实现Ibinder接口，以在onBind方法中返回\r\n\r\n\t\tclass ZhongJianRen extends Binder implements PublicBusiness{\r\n\t\tpublic void QianXian(){\r\n\t\t\t//访问服务中的banZheng方法\r\n\t\t\tBanZheng();\r\n\t\t}\t\r\n\t\tpublic void daMaJiang(){\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n* 把QianXian方法抽取到接口PublicBusiness中定义\r\n\r\n---\r\n#两种启动方法混合使用\r\n* 用服务实现音乐播放时，因为音乐播放必须运行在服务进程中，可是音乐服务中的方法，需要被前台Activity所调用，所以需要混合启动音乐服务\r\n* 先start，再bind，销毁时先unbind，在stop\r\n\r\n---\r\n##使用服务注册广播接收者\r\n* Android四大组件都要在清单文件中注册\r\n* 广播接收者比较特殊，既可以在清单文件中注册，也可以直接使用代码注册\r\n* 有的广播接收者，必须代码注册\r\n\t* 电量改变\r\n\t* 屏幕锁屏和解锁\r\n\r\n* 注册广播接收者\r\n\r\n\t\t//创建广播接收者对象\r\n\t\treceiver = new ScreenOnOffReceiver();\r\n\t\t//通过IntentFilter对象指定广播接收者接收什么类型的广播\r\n\t\tIntentFilter filter = new IntentFilter();\r\n\t\tfilter.addAction(Intent.ACTION_SCREEN_OFF);\r\n\t\tfilter.addAction(Intent.ACTION_SCREEN_ON);\r\n\t\t\r\n\t\t//注册广播接收者\r\n\t\tregisterReceiver(receiver, filter);\r\n* 解除注册广播接收者\r\n\r\n\t\tunregisterReceiver(receiver);\r\n* 解除注册之后，广播接收者将失去作用\r\n\r\n##本地服务：服务和启动它的组件在同一个进程\r\n##远程服务：服务和启动它的组件不在同一个进程\r\n* 远程服务只能隐式启动，类似隐式启动Activity，在清单文件中配置Service标签时，必须配置intent-filter子节点，并指定action子节点\r\n\r\n#AIDL\r\n* Android interface definition language\r\n* 安卓接口定义语言\r\n* 作用：跨进程通信\r\n* 应用场景：远程服务中的中间人对象，其他应用是拿不到的，那么在通过绑定服务获取中间人对象时，就无法强制转换，使用aidl，就可以在其他应用中拿到中间人类所实现的接口\r\n\r\n##支付宝远程服务\r\n1. 定义支付宝的服务，在服务中定义pay方法\r\n2. 定义中间人对象，把pay方法抽取成接口\r\n3. 把抽取出来的接口后缀名改成aidl\r\n4. 中间人对象直接继承Stub对象\r\n5. 注册这个支付宝服务，定义它的intent-Filter\r\n\r\n##需要支付的应用\r\n1. 把刚才定义好的aidl文件拷贝过来，注意aidl文件所在的包名必须跟原包名一致\r\n2. 远程绑定支付宝的服务，通过onServiceConnected方法我们可以拿到中间人对象\r\n3. 把中间人对象通过Stub.asInterface方法强转成定义了pay方法的接口\r\n4. 调用中间人的pay方法\r\n\r\n##五种前台进程\r\n1. activity执行了onresume方法，获得焦点\r\n2. 拥有一个跟正在与用户交互的activity绑定的服务\r\n3. 拥有一个服务执行了startForeground()方法\r\n4. 拥有一个正在执行onCreate()、onStart()或者onDestroy()方法中的任意一个的服务\r\n5. 拥有一个正在执行onReceive方法的广播接收者\r\n\r\n##两种可见进程\r\n1. activity执行了onPause方法，失去焦点，但是可见\r\n2. 拥有一个跟可见或前台activity绑定的服务",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}